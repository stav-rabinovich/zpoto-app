// cleanup.service.ts - ◊™◊ô◊ß◊ï◊ü ◊û◊¶◊ë◊ô◊ù ◊ú◊ê ◊™◊ß◊ô◊†◊ô◊ù ◊ë◊û◊¢◊®◊õ◊™
import { prisma } from '../lib/prisma';

/**
 * ◊™◊ô◊ß◊ï◊ü ◊û◊©◊™◊û◊©◊ô◊ù ◊©◊†◊©◊ê◊®◊ï ◊¢◊ù role OWNER ◊ê◊ë◊ú ◊ë◊ú◊ô ◊ó◊†◊ô◊ï◊™
 */
export async function fixOrphanedOwners() {
  console.log('üîß Starting orphaned owners cleanup...');

  try {
    // ◊û◊¶◊ô◊ê◊™ ◊õ◊ú ◊î◊û◊©◊™◊û◊©◊ô◊ù ◊¢◊ù role OWNER
    const owners = await prisma.user.findMany({
      where: { role: 'OWNER' },
      select: { id: true, email: true, name: true },
    });

    console.log(`üîç Found ${owners.length} users with OWNER role`);

    const fixedUsers = [];

    for (const owner of owners) {
      // ◊ë◊ì◊ô◊ß◊î ◊ê◊ù ◊ô◊© ◊ú◊ï ◊ó◊†◊ô◊ï◊™
      const parkingCount = await prisma.parking.count({
        where: { ownerId: owner.id },
      });

      if (parkingCount === 0) {
        // ◊ê◊ô◊ü ◊ú◊ï ◊ó◊†◊ô◊ï◊™ - ◊¶◊®◊ô◊ö ◊ú◊î◊ó◊ñ◊ô◊® ◊ê◊ï◊™◊ï ◊ú-USER
        console.log(`üîß Fixing user ${owner.id} (${owner.email}) - no parkings found`);

        await prisma.user.update({
          where: { id: owner.id },
          data: { role: 'USER' },
        });

        fixedUsers.push({
          id: owner.id,
          email: owner.email,
          name: owner.name,
          issue: 'OWNER without parkings',
        });
      }
    }

    console.log(`‚úÖ Fixed ${fixedUsers.length} orphaned owners`);

    return {
      success: true,
      message: `Fixed ${fixedUsers.length} orphaned owners`,
      fixedUsers,
    };
  } catch (error: any) {
    console.error('‚ùå Error in orphaned owners cleanup:', error);
    return {
      success: false,
      error: error?.message || 'Unknown error',
    };
  }
}

/**
 * ◊ë◊ì◊ô◊ß◊î ◊õ◊ú◊ú◊ô◊™ ◊©◊ú ◊™◊ß◊ô◊†◊ï◊™ ◊î◊û◊¢◊®◊õ◊™
 */
export async function systemHealthCheck() {
  console.log('üè• Starting system health check...');

  try {
    const issues = [];

    // ◊ë◊ì◊ô◊ß◊î 1: ◊û◊©◊™◊û◊©◊ô◊ù ◊¢◊ù OWNER ◊ú◊ú◊ê ◊ó◊†◊ô◊ï◊™
    const ownersWithoutParkings = await prisma.user.count({
      where: {
        role: 'OWNER',
        ownedParkings: { none: {} },
      },
    });

    if (ownersWithoutParkings > 0) {
      issues.push({
        type: 'ORPHANED_OWNERS',
        count: ownersWithoutParkings,
        description: '◊û◊©◊™◊û◊©◊ô◊ù ◊¢◊ù role OWNER ◊ê◊ë◊ú ◊ë◊ú◊ô ◊ó◊†◊ô◊ï◊™',
      });
    }

    // ◊ë◊ì◊ô◊ß◊î 2: ◊ó◊†◊ô◊ï◊™ ◊ú◊ú◊ê ◊ë◊¢◊ú◊ô◊ù
    const parkingsWithoutOwners = await prisma.parking.count({
      where: {
        NOT: {
          owner: {
            id: {
              gt: 0,
            },
          },
        },
      },
    });

    if (parkingsWithoutOwners > 0) {
      issues.push({
        type: 'ORPHANED_PARKINGS',
        count: parkingsWithoutOwners,
        description: '◊ó◊†◊ô◊ï◊™ ◊ú◊ú◊ê ◊ë◊¢◊ú◊ô◊ù',
      });
    }

    // ◊ë◊ì◊ô◊ß◊î 3: ◊ë◊ß◊©◊ï◊™ ◊©◊ê◊ï◊©◊®◊ï ◊ê◊ë◊ú ◊î◊û◊©◊™◊û◊© ◊ú◊ê OWNER
    const approvedRequestsWithoutOwnerRole = await prisma.listingRequest.count({
      where: {
        status: 'APPROVED',
        user: {
          role: { not: 'OWNER' },
        },
      },
    });

    if (approvedRequestsWithoutOwnerRole > 0) {
      issues.push({
        type: 'APPROVED_WITHOUT_ROLE',
        count: approvedRequestsWithoutOwnerRole,
        description: '◊ë◊ß◊©◊ï◊™ ◊û◊ê◊ï◊©◊®◊ï◊™ ◊ê◊ë◊ú ◊î◊û◊©◊™◊û◊© ◊ú◊ê OWNER',
      });
    }

    console.log(`üè• Health check completed - found ${issues.length} issues`);

    return {
      success: true,
      healthy: issues.length === 0,
      issues,
      summary: issues.length === 0 ? 'System is healthy' : `Found ${issues.length} issues`,
    };
  } catch (error: any) {
    console.error('‚ùå Error in system health check:', error);
    return {
      success: false,
      error: error?.message || 'Unknown error',
    };
  }
}

/**
 * ◊™◊ô◊ß◊ï◊ü ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊©◊ú ◊õ◊ú ◊î◊ë◊¢◊ô◊ï◊™ ◊©◊†◊û◊¶◊ê◊ï
 */
export async function autoFixSystemIssues() {
  console.log('üîß Starting automatic system fixes...');

  try {
    const results = [];

    // ◊™◊ô◊ß◊ï◊ü 1: ◊û◊©◊™◊û◊©◊ô◊ù ◊ô◊™◊ï◊û◊ô◊ù
    const orphanedOwnersResult = await fixOrphanedOwners();
    results.push({
      type: 'ORPHANED_OWNERS',
      result: orphanedOwnersResult,
    });

    // ◊õ◊ê◊ü ◊ê◊§◊©◊® ◊ú◊î◊ï◊°◊ô◊£ ◊™◊ô◊ß◊ï◊†◊ô◊ù ◊†◊ï◊°◊§◊ô◊ù ◊ë◊¢◊™◊ô◊ì

    const successCount = results.filter(r => r.result.success).length;

    return {
      success: successCount === results.length,
      message: `Completed ${successCount}/${results.length} fixes`,
      results,
    };
  } catch (error: any) {
    console.error('‚ùå Error in auto fix:', error);
    return {
      success: false,
      error: error?.message || 'Unknown error',
    };
  }
}
